# Deep Dive по проекту `reestr-mkd`

Документ фиксирует текущее состояние архитектуры, схемы БД, логики и рабочего процесса (Workflow) для тестового DEV-проекта, который сейчас работает через Supabase/PostgreSQL и допускает полный reset схемы.

## 1) Назначение и контекст

- Проект — фронтенд-система «Реестр многоквартирных домов» для ведения заявки и поэтапной инвентаризации объекта: паспорт, состав комплекса, этажи/подъезды/помещения, реестры и интеграция.  
- Среда — тестовая: схема БД может быть пересобрана полностью, данные не являются критичными.  
- Бэкенд-персистентность реализована напрямую через Supabase JS-клиент (PostgreSQL + RLS-политики для DEV).

## 2) Технологический стек

- UI: React 18 + React Router + Tailwind.  
- Data layer: TanStack Query (загрузка проекта) + собственный Sync Layer для пакетного сохранения.  
- DB/API: `@supabase/supabase-js` с прямыми запросами в таблицы (`projects`, `applications`, `buildings`, `floors`, `units`, и др.).  
- Валидация: кастомные step-валидаторы + вспомогательные схемы/утилиты.

## 3) Архитектура приложения (высокий уровень)

### 3.1 Контур UI

- `App.jsx` собирает роутинг, экран логина, дашборд заявок, редактор проекта и админ-панель справочников.  
- Внутри редактора шаги выбираются из `STEPS_CONFIG` и рендерятся как отдельные редакторы (паспорт, конфигураторы, матрицы, реестры, интеграция).

### 3.2 Контур состояния проекта

- Центральный контейнер — `ProjectProvider` (`ProjectContext`):
  - Загружает полный срез проекта (`useProjectData`).
  - Мержит серверный срез + локальные изменения (`useProjectDataLayer`).
  - Сохраняет изменения очередью/батчами (`useProjectSyncLayer`).
  - Управляет переходами Workflow (`useProjectWorkflowLayer`).

### 3.3 Контур персистентности

- `ApiService` — единая точка чтения/записи в Supabase:
  - список проектов,
  - создание проекта и заявки,
  - полная загрузка контекста проекта,
  - сохранение сущностей по разделам (здания, этажи, помещения, МОП, паркинг, workflow).
- `db-mappers` переводит DB-модель (snake_case, плоские таблицы) в UI-модель (camelCase, агрегаты) и обратно.

## 4) Логика Workflow (жизненный цикл заявки)

### 4.1 Статусы

Базовые статусы заявки:
- `NEW` → `DRAFT` → `REVIEW` → `REJECTED`/`INTEGRATION`/`COMPLETED`.

Ролевая модель:
- `technician`: вводит/редактирует в рабочих статусах.
- `controller`: проверяет этапы.
- `admin`: полный доступ.

### 4.2 Этапы и контрольные точки

Всего 17 шагов (`STEPS_CONFIG`, индексы 0..16), сгруппированных в 4 этапа (`WORKFLOW_STAGES`):
- Этап 1: до шага 5 (инвентаризация до подъездов).
- Этап 2: до шага 8 (квартиры/МОП/паркинг конфиг).
- Этап 3: до шага 11 (реестры).
- Этап 4: до шага 16 (интеграция + сводные).

Ключевая механика:
- При завершении обычного шага: сдвиг `currentStepIndex`.
- На границе этапа: перевод в `REVIEW` и ожидание контролера.
- На входе в интеграционный сегмент: `INTEGRATION`.
- На последнем шаге: `COMPLETED`.

### 4.3 Проверка/возврат

- Контролер:
  - `APPROVE` возвращает процесс в рабочий режим следующего отрезка.
  - `REJECT` откатывает на предыдущий этап и проставляет `REJECTED` + комментарий.
- История (`application_history`) пишется на ключевых действиях.
- Прогресс по шагам хранится в `application_steps` (completed/verified).

## 5) Схема БД (PostgreSQL / Supabase)

Ниже логическая декомпозиция схемы из `db/reset_schema.sql`.

### 5.1 Ядро и workflow

- `projects` — карточка проекта/ЖК.
- `applications` — 1:1 к `projects` (через `project_id unique`), хранит workflow-состояние (`status`, `current_step`, `current_stage`, `integration_data`).
- `application_history` — журнал действий.
- `application_steps` — состояние шагов, уникальность `(application_id, step_index)`.

### 5.2 Паспортная часть проекта

- `project_participants` — роли/участники проекта (уникальность `project_id + role`).
- `project_documents` — документы проекта.

### 5.3 Объектная модель

- `buildings` — здания/сооружения проекта.
- `building_blocks` — блоки здания (тип, диапазон этажей, подъезды, подвал/чердак/лофт/кровля и т.п.).
- 1:1 расширения блока:
  - `block_construction` (конструктив),
  - `block_engineering` (инженерия).
- Подземная часть:
  - `basements`,
  - `basement_parking_levels` (уникальность `basement_id + depth_level`).

### 5.4 Этажи, подъезды, помещения

- `floors` — этажи/уровни (включая специальные флаги: technical/commercial/stylobate/basement/attic/loft/roof).
- `entrances` — подъезды по блоку.
- `entrance_matrix` — матрица подъезд × этаж (уникальность `block_id + floor_id + entrance_number`).
- `units` — помещения/машиноместа.
- `rooms` — экспликация помещений.
- `common_areas` — МОП.

### 5.5 Справочники (`dict_*`)

- Статусы, внешние системы, конструктивные типы, типы парковки, инфраструктура, типы помещений/комнат.
- Для большинства справочников обеспечивается `UNIQUE(code)` (кроме `dict_room_types`, где уникальна пара `(code, room_scope)`).

### 5.6 DEV-RLS и доступ

- Скрипт включает RLS для всех таблиц и ставит permissive-политики для `anon/authenticated`.
- Это валидно только для DEV/тестового контура.

## 6) Потоки данных (Data Flow)

### 6.1 Загрузка

1. `useProjectData` вызывает `ApiService.getProjectFullData(scope, projectId)`.  
2. `ApiService` тянет core-таблицы + здания/блоки + workflow + матрицы/реестры, агрегирует в UI-формат через мапперы.  
3. `ProjectContext` публикует единое состояние редакторам шагов.

### 6.2 Изменения и сохранение

1. UI-шаги меняют куски состояния через setters из `ProjectContext`.  
2. `useProjectSyncLayer` накапливает обновления в `pendingUpdatesRef`.  
3. `saveProjectImmediate()` последовательно отправляет пачки изменений в БД через `ApiService.saveData(...)`.  
4. После сохранения делается `refetch` для консистентного снимка.

### 6.3 Workflow-события

- Кнопки в `WorkflowBar` делают: validate → save → transition (`completeTask`/`rollbackTask`/`reviewStage`) → persist → refetch.

## 7) DEV-процесс reset схемы

Официальный runbook:
1. Открыть Supabase SQL Editor.  
2. Выполнить `db/reset_schema.sql` целиком.  
3. Пройти smoke-check ключевых шагов UI (паспорт, состав, этажи/подъезды, реестры, интеграция).

Это соответствует заявленному тестовому сценарию, где данные не сохраняются как ценность, а схема может быть восстановлена с нуля.

## 8) Практический WorkFlow команды (как работать безопасно в DEV)

- Перед любым крупным refactor:
  1) reset схемы;  
  2) smoke по этапам 1→4;  
  3) проверка переходов REVIEW/REJECT/INTEGRATION;  
  4) проверка целостности связей (`projects`↔`applications`, `buildings`→`blocks`→`floors`→`units/rooms`).
- Для каждого изменения в данных/схеме:
  - сначала сверять контракт с `ApiService` и `db-mappers`;  
  - фиксировать изменение в docs и runbook;  
  - прогонять минимум `npm run lint` + smoke ручной сценарий по затронутым шагам.

